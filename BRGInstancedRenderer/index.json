{
  "README.html": {
    "href": "README.html",
    "title": "Documentation | BRG Instanced Renderer",
    "summary": "Documentation This repository hosts the documentation for BRG Instanced Renderer. Built With This documentation site is built using docfx. The documentation articles are located in articles/ and written in markdown format. Getting Started Installing docfx: dotnet tool install -g docfx Serving the docs on localhost: docfx --serve Adding New Articles Create a new .md file in articles/, and link it in articles/toc.md."
  },
  "articles/api/core-methods.html": {
    "href": "articles/api/core-methods.html",
    "title": "Core Methods | BRG Instanced Renderer",
    "summary": "Core Methods Public methods on the BRGInstancedRenderer singleton for runtime control. Access the singleton via BRGInstancedRenderer.Instance. SetDensity public void SetDensity(float density) Set the global density scale (0–1). Prototypes with Enable Density Scaling enabled on their BRG Prototype Extra Data will thin out instances proportionally. Parameter Type Description density float Density multiplier, clamped to 0–1. 1 = full density, 0 = maximum culling. // reduce density to 50% (e.g. as a graphics setting) BRGInstancedRenderer.Instance.SetDensity(0.5f); // restore full density BRGInstancedRenderer.Instance.SetDensity(1f); RuntimeRefresh public void RuntimeRefresh() A faster refresh path for use at runtime. Shuts down and re-initializes all active registerers, causing them to re-extract and re-upload their instance data. Use this after you have programmatically changed terrain data, swapped prefabs, or modified prototype settings at runtime. BRGInstancedRenderer.Instance.RuntimeRefresh(); CompactBuffers public void CompactBuffers() Compacts the internal instance pool and chunk buffers to reduce GPU memory waste. Leaves approximately 25% headroom above current usage. This causes a small frame hitch, so call it during pauses, loading screens, or scene transitions rather than during gameplay. // compact during a loading screen BRGInstancedRenderer.Instance.CompactBuffers(); The Config also provides an Enable Auto Compaction option that runs compaction automatically when utilization is low, but manual compaction is recommended to prevent hitches. SnapCrossfadeStates public void SnapCrossfadeStates() Snap all animated crossfade transitions to their target LOD immediately, skipping the fade animation. Call this after teleporting the camera or loading a new scene area to prevent a mass fade-in of all visible instances. // after teleporting the player player.transform.position = newPosition; BRGInstancedRenderer.Instance.SnapCrossfadeStates(); SnapCrossfadeState public bool SnapCrossfadeState(Camera camera) public bool SnapCrossfadeState(int viewID) Snap animated crossfade for a single camera or view. Returns false if the view has not been seen by the culling system yet. The Camera overload is a convenience wrapper that passes camera.GetInstanceID() to the int overload. Parameter Type Description camera Camera The camera to snap crossfade for. viewID int The view identifier (camera instance ID or shadow view ID). Returns Description bool true if the view was found and snapped, false if the view ID is unknown. // snap crossfade for a specific camera after teleporting it BRGInstancedRenderer.Instance.SnapCrossfadeState(myCamera);"
  },
  "articles/api/custom-registerer.html": {
    "href": "articles/api/custom-registerer.html",
    "title": "Custom Registerer | BRG Instanced Renderer",
    "summary": "Custom Registerer BRGRegisterer is an abstract base class for building your own instance registration components. It handles the BRG singleton lifecycle, prototype reference counting, chunk tracking with automatic cleanup, overflow management, and editor support — so your subclass only needs to focus on what to register and where. Both built-in registerers (BRG Instance Group and BRG Terrain Registerer) extend this class. For a working example, see Registerer Example. Creating a Custom Registerer Extend BRGRegisterer and implement two methods: using Unity.Collections; using Unity.Mathematics; using UnityEngine; namespace BRGInstancedRenderer { public class MyRegisterer : BRGRegisterer { [SerializeField] GameObject _prefab; int _protoIndex = -1; ChunkLink _chunk; protected override void OnInitialize() { // 1. Register your prototype _protoIndex = BaseRegisterPrototype(_prefab); if (_protoIndex < 0) return; // 2. Allocate a chunk _chunk = AllocChunk(); if (!_chunk.IsValid) return; // 3. Build instance data var instances = new NativeArray<InstanceData>(100, Allocator.TempJob); for (int i = 0; i < 100; i++) { instances[i] = new InstanceData { position = new float3(i * 2f, 0f, 0f), rotation = quaternion.identity, scale = new float3(1f), prototypeIndex = _protoIndex, color = new Color32(255, 255, 255, 255) }; } // 4. Write to the chunk var bounds = new Bounds(Vector3.zero, new Vector3(200f, 10f, 10f)); WriteChunk(_chunk, instances, bounds); instances.Dispose(); } protected override void OnShutdown() { // Clean up local state only. // Do NOT free chunks or unregister prototypes - the base class does that. _chunk = ChunkLink.Invalid; _protoIndex = -1; } } } The base class automatically: Acquires the BRGInstancedRenderer singleton Calls OnInitialize() on enable, OnShutdown() on disable Frees all chunks allocated via AllocChunk() on shutdown Unregisters all prototypes registered via BaseRegisterPrototype() on shutdown Handles editor lifecycle ([ExecuteAlways] with deferred initialization) Structs InstanceData Per-instance data for registration and updates. Field Type Description position float3 World-space position. rotation quaternion World-space rotation. scale float3 Local scale. prototypeIndex int Global prototype index returned by BaseRegisterPrototype. color Color32 Per-instance color tint. Requires Enable Per-Instance Color on the Config. PrototypeData Explicit prototype configuration for batch registration via BaseRegisterPrototypes. Most users can use BaseRegisterPrototype(GameObject) instead, which extracts this data from the prefab automatically. Field Type Description sourcePrefab GameObject Original prefab (used for identity comparison). mesh Mesh Base mesh (LOD 0). materials Material[] Materials per submesh (LOD 0). lodMeshes Mesh[] Additional LOD meshes (LOD 1+). lodMaterials Material[][] Materials per LOD level. lodScreenSizes float[] Screen relative heights for LOD transitions. lodFadeTransitionWidths float[] Crossfade width per LOD level. lodCastsShadows bool[] Whether each LOD casts shadows. lodGroupSize float Reference size for LOD calculations. fadeMode LODFadeMode Crossfade mode from LODGroup. maxShadowCascade int Max shadow cascades (default 4). minShadowLOD int Minimum LOD for shadow mesh (default 0). maxShadowDistance float Max shadow distance, 0 = global (default 0). enableDensityScaling bool Enable runtime density scaling. enableDynamicDensity bool Enable per-instance dynamic density. dynamicDensityMode DynamicDensityMode ScreenSize or Distance. layer int GameObject layer from prefab. renderingLayerMask uint URP/HDRP rendering layer mask. ChunkLink Handle to an allocated BRG chunk. Tracked by the base class for automatic cleanup. Member Type Description Id int Internal chunk identifier. IsValid bool true if the chunk was successfully allocated. Invalid static Sentinel value for an invalid chunk. InstanceLink Handle to a single instance within a chunk. Provides convenience methods for per-instance modification. Method Description SetColor(Color32) Set per-instance color. SetPosition(float3) Set position only. SetRotation(quaternion) Set rotation only. SetScale(float3) Set scale only. MoveAndRotate(float3, quaternion) Set position and rotation. Move(float3, quaternion, float3) Set full TRS (position, rotation, scale). SampleLightProbe(float3) Re-sample light probes at the given position. Remove() Remove this instance from its chunk. Property Type Description SlotIndex int Global slot index in the instance buffer. ChunkId int The chunk this instance belongs to (may be an overflow chunk). IsValid bool true if the instance handle is valid. Protected Properties Property Type Description BRGSystem BRGInstancedRenderer Reference to the singleton. Set before OnInitialize() is called, cleared after OnShutdown() returns. Use it freely during those methods. _registered bool true while the registerer is initialized. Check this before performing operations. Manual Lifecycle By default, BRGRegisterer initializes on OnEnable and shuts down on OnDisable. If you need manual control (e.g., a button-driven workflow), override OnEnable/OnDisable and call these methods directly: Method Description void Initialize() Acquire the singleton and call OnInitialize(). Safe to call multiple times — does nothing if already registered. void Shutdown() Call OnShutdown(), free all tracked chunks and prototypes, and release the singleton. See the Registerer Example for a working example of manual lifecycle using _autoRegister. Protected API These methods are available to your BRGRegisterer subclass. Prototype Registration Method Description int BaseRegisterPrototype(GameObject prefab) Register a single prefab as a prototype. Returns the global prototype index, or -1 on failure. Tracked for automatic unregistration. Dictionary<int,int> BaseRegisterPrototypes(List<PrototypeData> prototypes) Batch-register prototypes from explicit data. Returns a local-to-global index remap dictionary. Tracked for automatic unregistration. Chunk Management Method Description ChunkLink AllocChunk() Allocate a new chunk. Tracked for automatic cleanup on shutdown. void WriteChunk(ChunkLink, NativeArray<InstanceData>, Bounds, ...) Write instances to a chunk. Automatically splits across overflow chunks if instance count exceeds MaxInstancesPerChunk. void ReleaseChunk(ChunkLink) Free a chunk and all its overflow chunks. Idempotent. void RecalculateChunkBounds(ChunkLink, Bounds) Update chunk culling bounds. Instance Management Method Description InstanceLink AddInstance(ChunkLink, InstanceData) Add a single instance. Tries the primary chunk, then overflow chunks, then allocates a new overflow if needed. Returns InstanceLink.Invalid on failure. InstanceLink[] AddInstances(ChunkLink, NativeArray<InstanceData>, int) Add multiple instances with automatic overflow. Returns an array of InstanceLink handles. Queries Method Description InstanceLink[] GetInstanceLinks(ChunkLink) Get InstanceLink handles for all instances in the chunk (primary + overflow). Only available for chunks written with createInstanceHandles = true. int[] GetInstanceSlots(ChunkLink) Get raw global slot indices for the primary chunk only. int GetTotalChunkInstanceCount(ChunkLink) Total instance count including overflow chunks. int GetOverflowChunkCount(ChunkLink) Number of overflow chunks attached to this chunk. void GetPerChunkInstanceCounts(ChunkLink, List<int>) Populates the list with instance counts: primary chunk at index 0, then each overflow chunk. Callbacks Method Description virtual void OnInstanceHandlesProvided(int chunkId) Called when deferred chunk writes complete for chunks with createInstanceHandles = true. Override to cache InstanceLink handles. WriteChunk Parameters The WriteChunk method has several optional parameters: Parameter Type Default Description link ChunkLink — The chunk to write to. instances NativeArray<InstanceData> — Instance data array. bounds Bounds — World-space AABB used for hierarchical culling. Should tightly enclose all instances. cullDistance float 0 Per-chunk max render distance. 0 = unlimited. snapAnimatedCrossfade bool false Skip the animated crossfade fade-in for these instances. Set to true for instances that already exist in the world (e.g. loaded from save). createInstanceHandles bool false Track per-instance slot indices, enabling GetInstanceLinks() and per-instance operations. Costs additional memory. Overflow Chunks When a WriteChunk call contains more instances than MaxInstancesPerChunk, the base class automatically allocates overflow chunks and splits the data across them. This is transparent to the subclass: GetInstanceLinks() returns handles from the primary chunk and all overflow chunks combined GetTotalChunkInstanceCount() sums across all chunks AddInstance() tries the primary chunk, then existing overflows, then allocates a new overflow ReleaseChunk() frees the primary chunk and all its overflows Notes Always use BaseRegisterPrototype / BaseRegisterPrototypes instead of calling BRGSystem.RegisterPrototype directly. The base class tracks these for automatic cleanup. Always use AllocChunk / ReleaseChunk instead of calling BRGSystem.AllocateChunk / FreeChunk directly, for the same reason. Do not free chunks or unregister prototypes in OnShutdown(). The base class handles all BRG resource cleanup after OnShutdown() returns. The BRGSystem property is set before OnInitialize() and cleared after OnShutdown(). Use it freely during those methods. BRGRegisterer is marked [ExecuteAlways], so it works in the editor outside of play mode."
  },
  "articles/api/registerer-example.html": {
    "href": "articles/api/registerer-example.html",
    "title": "Registerer Example | BRG Instanced Renderer",
    "summary": "Registerer Example BRGRegistererExample is a working example of a Custom Registerer included in the Examples folder. It demonstrates prototype registration, chunk allocation, per-instance mutation, and the inspector-driven workflow for testing BRG features. Setup Property Type Default Description Prefab GameObject — Prefab to render. Must have a MeshFilter + MeshRenderer (or LODGroup). Chunk Settings Property Type Default Description Chunk Size int 25 Physical size of the chunk in world units. Chunk Padding float 1 Extra padding added to chunk bounds. Initial Instance Count int 256 Number of instances to spawn per grid chunk. Cull Distance float 0 Max render distance for the chunk. 0 = unlimited. Snap Animated Crossfade On First Frame bool true Skip animated crossfade fade-in on first appearance (instances pop in instantly). Create Instance Handles bool true Track per-instance slot indices for runtime mutation. Costs memory — only enable if you need to move, color, or remove individual instances. Lifecycle Property Type Default Description Auto Register bool true Automatically initialize on enable and shutdown on disable. When off, use the Initialize / Shutdown buttons in the inspector. When Auto Register is disabled, the inspector shows a Manual Lifecycle section with Initialize and Shutdown buttons, along with the current registration status. Inspector Controls Once registered, the inspector provides runtime controls: Global Button Description Create Grid Chunk Allocate a new chunk and fill it with instances arranged in a grid pattern. Each new chunk is offset so they don't overlap. Create Empty Chunk Allocate an empty chunk with no instances. Use Add Instance to populate it one at a time. Per Chunk Each chunk shows its ID, instance count, and a set of action buttons: Button Description Add Instance Add a single instance at a random position within the chunk bounds, with a random color. Remove Random Remove a random instance from the chunk. Randomize Colors Set all instances to random colors (requires Enable Per-Instance Color on the Config). Randomize Scales Set all instances to random scales between 0.3 and 2.0. Scatter Positions Move all instances to random positions within the chunk bounds. Delete Chunk Free the chunk and all its instances. The per-instance buttons (Add, Remove, Colors, Scales, Scatter) require Create Instance Handles to be enabled, since they use InstanceLink handles to modify individual instances. How It Works The example demonstrates the key steps of a custom registerer: OnInitialize Registers the assigned prefab via BaseRegisterPrototype() Creates an initial grid chunk via CreateGridChunk() OnShutdown Clears local chunk state. The base class handles freeing chunks and unregistering prototypes. OnInstanceHandlesProvided When a chunk is written with createInstanceHandles = true, the slot indices may not be available immediately (deferred GPU upload). The base class calls OnInstanceHandlesProvided(chunkId) once the handles are ready. The example caches InstanceLink handles at this point for use by the per-instance buttons. Instance Mutation The per-instance buttons demonstrate using InstanceLink methods: // add an instance var link = AddInstance(chunkState.link, new InstanceData { position = randomPosition, rotation = quaternion.identity, scale = new float3(1f), prototypeIndex = _protoIndex, color = new Color32(255, 128, 64, 255) }); // modify it later link.SetColor(new Color32(0, 255, 0, 255)); link.SetPosition(newPosition); link.SetScale(new float3(1.5f)); // remove it link.Remove(); Debug Property Type Default Description Show Chunk Gizmos bool true Draw wireframe boxes in the Scene View showing chunk bounds. Each chunk gets a unique color."
  },
  "articles/components/brg-camera-settings.html": {
    "href": "articles/components/brg-camera-settings.html",
    "title": "BRG Camera Settings | BRG Instanced Renderer",
    "summary": "BRG Camera Settings An optional component added to cameras to control the LOD bias multiplier for BRG Instanced Renderer on a per-camera basis. Inspector Properties Property Type Default Description LOD Bias Multiplier float (0.01–10) 1.0 A multiplier applied on top of Unity's global QualitySettings.lodBias. How It Works The final LOD bias used for a camera is: Final LOD Bias = QualitySettings.lodBias x LOD Bias Multiplier A multiplier of 1.0 uses the global Quality Settings value as-is (default behavior). A multiplier greater than 1.0 pushes LOD transitions farther away, keeping higher-detail meshes visible at greater distances. A multiplier less than 1.0 pulls LOD transitions closer, using lower-detail meshes sooner. When to Use Cinematic cameras — Set a higher multiplier to maintain maximum detail for cutscenes or beauty shots. Minimap or overview cameras — Set a lower multiplier to aggressively use lower LODs, since detail isn't needed. Split-screen or secondary cameras — Reduce LOD quality on secondary viewports to save rendering budget. Methods SnapCrossfade public void SnapCrossfade() Snaps all animated crossfade transitions to their target LOD for this camera. Convenience wrapper around SnapCrossfadeState on the singleton. // snap crossfade after teleporting this camera GetComponent<BRGCameraSettings>().SnapCrossfade(); Notes If no BRG Camera Settings component is present on a camera, the standard QualitySettings.lodBias is used with a multiplier of 1.0. This component only affects LOD selection within BRG Instanced Renderer. It does not change Unity's built-in LOD behavior for non-BRG objects."
  },
  "articles/components/brg-instance-group.html": {
    "href": "articles/components/brg-instance-group.html",
    "title": "BRG Instance Group | BRG Instanced Renderer",
    "summary": "BRG Instance Group Converts a hierarchy of prefab instances into GPU-instanced rendering via BRG Instanced Renderer. Instances are spatially batched into chunks and serialized, so startup is instant with no runtime transform scanning. For a step-by-step setup guide, see Getting Started: GameObjects. Inspector Properties Property Type Default Description Chunk Size float 50m World-space size of the spatial grid cells. Instances are grouped into chunks based on their position. Affects culling granularity — smaller chunks cull more precisely, larger chunks reduce overhead. Cull Distance float 0 Maximum render distance in meters. Instances in this group beyond this distance are not rendered. 0 means no distance limit. Show Chunk Gizmos bool true Draws wireframe bounding boxes in the Scene View for each chunk, color-coded by fill percentage. Inspector Actions Button Description Convert Children to Instances Scans all direct children, groups them into spatial chunks, serializes the data, and disables their Mesh Renderers and LOD Groups. Revert to GameObjects Re-enables original Mesh Renderers and LOD Groups, returning to standard Unity rendering. Refresh Rebuilds chunk data from the current state of the source objects. Use after moving, adding, or removing instances. You can also convert arbitrary GameObjects (not just children) via the hierarchy context menu: GameObject > BRG > Convert to BRG Instances. This creates a new BRG Instance Group and converts the selected objects into it. Status Display When converted, the inspector shows: Converted: Yes/No Chunk Count: Number of spatial chunks Prototype Count: Number of unique prefab types Instance Count: Total instances across all chunks How Chunks Work During conversion, instances are placed into a spatial grid based on their world position and the Chunk Size setting. If a grid cell exceeds the maximum instance capacity (determined by Config pool settings), it is split into multiple chunks. Each chunk stores: A bounding box used for hierarchical culling Instance data (position, rotation, scale, prototype index) The cull distance for distance-based culling Chunks are the first level of the hierarchical culling pipeline — chunks outside the camera frustum or behind occluders are skipped entirely before any per-instance work. Notes Source GameObjects remain in the hierarchy after conversion. Their renderers are disabled but you can still select and move them. After editing source objects, always click Refresh to update the serialized chunk data. Each source object gets a BRG Instance Link component that tracks its relationship to the group. Mixed prefab types under the same parent are fully supported. Each unique prefab becomes a separate prototype."
  },
  "articles/components/brg-instanced-renderer-config.html": {
    "href": "articles/components/brg-instanced-renderer-config.html",
    "title": "BRG Instanced Renderer Config | BRG Instanced Renderer",
    "summary": "BRG Instanced Renderer Config The global configuration asset for BRG Instanced Renderer. This ScriptableObject controls culling behavior, memory allocation, shadow settings, LOD crossfade, and debug options. The config asset is located at Assets/BRG Instanced Renderer/BRGIRConfig.asset and must be registered in Edit > Project Settings > Player > Preloaded Assets. To select the active config in the Project window, use the menu Tools > BRG Instanced Renderer > Select Config. Culling Property Type Default Description Use BRG Occlusion Culling bool true Enables per-chunk occlusion testing against Unity's baked occlusion data. Chunks fully hidden behind occluders are skipped. Pooling These settings control memory allocation for instance storage. Adjusting these affects GPU memory usage and culling granularity. Property Type Default Description Pool Size int 64 Number of instance slots per memory pool. Valid values: 64, 128, or 256. Smaller values waste less memory on partially-filled pools. Larger values reduce the number of pools to manage. Max Pools Per Chunk int 32 Maximum number of pools each chunk can hold. Higher values allow more instances per chunk, meaning fewer chunks to cull but less granular culling. Initial Chunk Count int 256 Starting number of chunk slots. Grows automatically as needed. Initial Pool Count int 1024 Starting number of pool slots. Grows automatically as needed. Enable Auto Compaction bool false When enabled, GPU buffers are periodically shrunk when waste exceeds 50%. Can cause frame hitches during compaction. Tip If you know your scene's approximate instance count, set the initial chunk and pool counts high enough to avoid runtime growth. Alternatively, use Gathered Allocations (below) to record peak values automatically. Light Probes Property Type Default Description Support Legacy Light Probes bool false Samples SphericalHarmonicsL2 per instance. Adds 128 bytes per instance to the GPU buffer (~65% total per-instance memory increase). Only needed if your project uses legacy light probes instead of APV. Per-Instance Color Property Type Default Description Enable Per-Instance Color bool false Enables per-instance color tinting. Each instance can have a unique color applied as a multiplicative tint. Adds a small amount of GPU buffer memory per instance. Shadows Property Type Default Description Max Shadow Crossfade Cascade int 4 Number of shadow cascades (starting from cascade 1) that use dithered crossfade. Smooths the seam between cascades. Set to 0 to disable. Can be overridden per-prototype via BRG Prototype Extra Data. LOD Crossfade Property Type Default Description Debug Disable Crossfade bool false Disables animated crossfade, forcing instant LOD transitions. Default Animated Crossfade Duration float 0.5s Time in seconds for animated LOD crossfade transitions. Applies to all prototypes unless overridden per-prefab. Skip Intermediate LODs bool true When an instance needs to transition multiple LOD levels (e.g., LOD0 to LOD3), skip intermediate levels and jump directly to the target. Reduces the number of fade transitions. Debug Property Type Default Description Enable Debug Logging bool false Outputs verbose logging to the console for all major operations. Debug Bypass Chunk Culling bool false Processes all instances regardless of chunk-level culling results. Useful for verifying that chunk culling is working correctly. Debug Disable Culling bool false Skips GPU culling entirely and reuses the previous frame's visibility. Useful for isolating culling cost in the profiler. Debug Disable Rendering bool false Runs GPU culling as normal but skips the actual BRG rendering. Useful for isolating rendering cost. Debug Visualize Culling In Scene View bool false Freezes culling to the Game camera's frustum so you can orbit in the Scene View and see what is being culled. Gathered Allocations The system can record peak allocation values during runtime and use them as initial sizes on the next run, eliminating runtime buffer growth. Property Type Description Record Allocations bool Record peak allocation sizes during play mode and use them as initial allocation sizes. Gathered Max Chunks int Peak chunk count from previous sessions. Gathered Max Pools int Peak pool count from previous sessions. Gathered Max Instances int Peak instance count from previous sessions. Peak values are recorded automatically during play mode. Button Description Copy to Initial Sizes Copies the gathered peak values to the Initial Chunk Count and Initial Pool Count fields in the Pooling section. A Pool Padding slider (1.0–1.25) adds headroom above the recorded peaks. Clear Gathered Data Resets all gathered values to zero. Inspector Controls The config inspector also shows: Button Description Set This As Active Registers this config in Preloaded Assets, replacing any existing config. Open System Window Opens the System Window for live statistics. The inspector validates that exactly one config is registered in Preloaded Assets and shows a warning if duplicates are found."
  },
  "articles/components/brg-prototype-extra-data.html": {
    "href": "articles/components/brg-prototype-extra-data.html",
    "title": "BRG Prototype Extra Data | BRG Instanced Renderer",
    "summary": "BRG Prototype Extra Data An optional component that you add to prefab assets to customize how BRG Instanced Renderer handles shadow rendering, LOD behavior, motion vectors, and dynamic density for that specific prefab type. Any prefab registered as a prototype (via BRG Instance Group or Terrain Registerer) will pick up these settings automatically. Shadow Optimizations Property Type Default Description Max Shadow Cascade int (1–4) 4 Maximum number of shadow cascades this prototype renders into. Lower values skip distant cascades. Set to 1 for grass and small details. Min Shadow LOD int (0–7) 0 Minimum LOD level used for shadow rendering. If set to 1, shadows use the LOD1 mesh instead of LOD0, reducing shadow polygon count. Override Max Shadow Distance bool false Enables the per-prototype max shadow distance below. Max Shadow Distance float 80m Cull shadows for this prototype beyond this distance. Only used when the override toggle is enabled. Override Max Shadow Crossfade Cascade bool false Enables the per-prototype shadow crossfade cascade override below. Max Shadow Crossfade Cascade int (0–4) — Number of shadow cascades using dithered crossfade for this prototype. Overrides the global value on the Config. For more details, see Shadow Optimization. Screen Size / LOD Overrides Animated Crossfade Duration When a LOD Group with animated crossfading is present on the prefab: Property Type Default Description Override Animated Crossfade Duration bool false Enables a per-prototype animated crossfade duration, overriding the global default on the Config. Animated Crossfade Duration float 0.5s Time in seconds for animated LOD crossfade transitions for this prototype. Screen Size Culling Disabled when a LOD Group or Mesh LOD is active (use the LOD Group's culled level or Mesh LOD's min screen size instead). Property Type Default Description Min Screen Size float (0–1) 0 Screen size percentage below which instances are culled. 0 means disabled. Fade Mode enum None How instances disappear at the cull boundary: None (instant pop), Crossfade (stateless dither), or Animated Crossfade (time-based fade). Fade Width float (0–1) 0 Width of the fade band for stateless crossfade mode. When Fade Mode is set to Animated Crossfade, the Override Animated Crossfade Duration field appears here instead of the LOD Group section above. Mesh LOD (Unity 6.2+) Disabled when a LOD Group is present. Requires a mesh with internal LOD ranges (lodCount > 1). Property Type Default Description Use Mesh LOD bool false Enables Mesh LOD mode. Num LODs int (1–8) 4 Number of BRG LOD levels to create from the mesh's internal LOD ranges. Fade Mode enum None Crossfade mode for Mesh LOD transitions: None (hard cut), Crossfade (stateless dither), or Animated Crossfade (time-based). When Fade Mode is set to Animated Crossfade, the Override Animated Crossfade Duration field appears here. Per BRG LOD level: Property Description Mesh LOD Index Which mesh LOD index to draw for this BRG LOD level. Screen Size Screen-size threshold for transitioning to this LOD. Must be monotonically decreasing. Fade Width Crossfade transition width (only shown with stateless Crossfade mode). The culled level uses the Min Screen Size property as its threshold. The inspector provides an Extract Screen Sizes from Mesh LOD Curve button that auto-populates screen-size thresholds from the mesh's native LOD selection curve. A LOD Selection Bias slider adjusts the renderer's bias for fine-tuning without modifying the mesh. For more details, see LOD Groups and Mesh LOD. Density Density Scaling Property Type Default Description Enable Density Scaling bool false Allows this prototype to participate in runtime global density scaling via BRGInstancedRenderer.SetDensity(). Dynamic Density Property Type Default Description Enable Dynamic Density bool false Enables GPU-side density culling for this prototype. Min Fraction float (0–1) 0.3 Minimum proportion of instances kept at maximum distance (30% by default). Fade Width float 0.05 Fade band width for smooth transitions. Only editable when the prototype has a stateless crossfade mode set (see below). Dynamic Density Mode enum ScreenSize Screen Size — density based on screen-space size. Distance — density based on world-space distance. Screen Size Mode —— —— ———————— Start Screen Size float (0.001–1) 0.1 Screen size percentage above which full density is maintained. Only shown in Screen Size mode. Distance Mode —— —— ———————— Start Distance float 50m Distance below which full density is maintained. Only shown in Distance mode. End Distance float 150m Distance at which minimum density is reached. Only shown in Distance mode. Density Fade Behavior Dynamic density uses the prototype's LOD crossfade mode for fade transitions. The crossfade mode is determined by whichever LOD system is active on the prototype: LOD Group, Min Screen Size culling, or Mesh LOD. Stateless Crossfade — the Fade Width field controls the fade band width. For screen-size mode this is a screen-size fraction; for distance mode this is a density fraction. Animated Crossfade — fade transitions use the animated crossfade duration automatically. The Fade Width field shows the fade duration in seconds. No crossfade mode — density-culled instances snap in and out with no fade. The inspector shows a help box recommending you set a crossfade mode via LOD Group, Min Screen Size culling, or Mesh LOD. For more details, see Dynamic Density. Other Settings Property Type Default Description Force No Motion Vectors bool false Disables motion vector generation for all LODs of this prototype. Saves GPU work for objects where TAA/motion blur quality doesn't matter. Notes Add this component to the prefab asset in the Project window, not to scene instances. Changes are detected automatically via the inspector. When you modify settings, BRG Instanced Renderer refreshes the affected prototype. If no BRG Prototype Extra Data component is present on a prefab, default values are used."
  },
  "articles/components/brg-terrain-registerer.html": {
    "href": "articles/components/brg-terrain-registerer.html",
    "title": "BRG Terrain Registerer | BRG Instanced Renderer",
    "summary": "BRG Terrain Registerer Registers a Unity Terrain's trees and details for GPU-instanced rendering through BRG Instanced Renderer. Trees are extracted once at startup. Details stream dynamically around the camera using C# Jobs and Burst Compiler. For a step-by-step setup guide, see Getting Started: Terrain. Settings Property Type Default Description Disable Built-In Rendering bool true Disables the terrain's native drawTreesAndFoliage, so BRG Instanced Renderer takes over all tree and detail rendering. Enable Debug Logging bool false Outputs detailed logging for tree extraction, detail streaming, and patch loading (Development builds only). Trees Property Type Default Description Cull Distance float — Read-only. Shows the terrain's Tree Distance setting. Adjust this in Unity's Terrain settings. Create Instance Handles bool false Store per-instance handles for trees, enabling per-instance operations like InstanceLink.SetColor. Increases memory usage. Required for GetTreeInstanceLinks(). Chunk Size float 256m World-space size of each spatial chunk for trees. Smaller values give better culling precision but more overhead. Show Chunk Gizmos bool false Draw wireframe boxes in the Scene View for each tree chunk, color-coded by fill percentage. Show Instance Spheres bool false Draw bounding spheres for each tree instance. Slow with many trees. Skip BRG Upload bool false Debug: skip GPU upload for trees. The inspector also shows a status line with tree prototype count, total instance count, and chunk count when registered. Details Streaming Property Type Default Description Preserve Prototype Layers bool false When enabled, detail instances keep their prefab's layer. When disabled, details use the terrain GameObject's layer (matches Unity's tree behavior). Cull Distance float — Read-only. Shows the terrain's Detail Object Distance setting. Adjust this in Unity's Terrain settings. Detail Chunk Size float 32m World-space size of detail streaming cells. Determines how finely details are streamed in and out around the camera. Snapped to terrain patch boundaries. The inspector shows computed read-only fields for Actual Chunk Size (snapped to patch boundaries) and Patch Size when a terrain is assigned. Property Type Default Description Use Streaming bool true When enabled, patches are loaded and unloaded based on camera distance. When disabled, all patches are loaded at startup. Max Patch Extracts Per Frame int 4 Maximum patches to extract data for per frame. Lower values give smoother loading but slower pop-in. Max Patch Unloads Per Frame int 8 Maximum patches to unload per frame when the camera moves away. Max Concurrent Extraction Jobs int 32 Maximum extraction jobs that can be in flight simultaneously. Complete Jobs Same Frame bool false Force extraction jobs to complete on the same frame they are scheduled. Eliminates pop-in at the cost of a per-patch main thread stall. Skip Extract Throttle On Start bool false Bypass the per-frame extract limit on the first frame so all in-range patches load immediately. Causes a one-time hitch but no pop-in. Update Interval float 0.1s How often to check for patch changes in seconds. 0 = every frame. Editor only. Unload Hysteresis float 10m Extra distance beyond the detail render distance to keep patches loaded, preventing rapid load/unload cycles at the boundary. Transform Generation Property Type Default Description Use Unity Transforms bool false Use Unity's ComputeDetailInstanceTransforms API instead of the custom extraction algorithm. Slower and allocates GC, but produces a 1:1 match with Unity's built-in detail rendering. Animated Crossfade Property Type Default Description Snap Crossfade On Start bool true Snap animated crossfade to the target LOD for patches already in range when the component initializes. Prevents a mass fade-in on scene load. Snap Crossfade On Load bool false Snap animated crossfade for patches streamed in during gameplay. When off, newly loaded details crossfade in smoothly. When on, they appear at their correct LOD immediately. Debug Property Type Default Description Show Chunk Gizmos bool false Draw wireframe boxes in the Scene View for each detail chunk, color-coded by fill percentage. Show Instance Spheres bool false Draw bounding spheres for each detail instance. Very slow — requires refresh to populate. Skip BRG Upload bool false Debug: skip GPU upload for details. The inspector also shows a status line with detail prototype count, patch grid size, loaded instance/patch/chunk counts, and pending patches. Detail Prefab Overrides (Editor Only) The inspector provides a Detail Prefab Overrides section where you can substitute terrain detail prototypes with LOD Group prefabs. Click Refresh Detail List to populate the list from the terrain's detail settings. Texture-based details show a warning prompting you to assign an override prefab for BRG rendering. Inspector Actions Button Description Refresh All Reloads all tree and detail data from the terrain. Call after modifying terrain data outside the paint tools. Clear Caches Clears cached extraction data and performs a full reload. Public Methods GetTreeInstanceLinks public InstanceLink[] GetTreeInstanceLinks() Returns InstanceLink handles for all registered tree instances. Requires Create Instance Handles to be enabled on the Trees section. Use these handles to modify individual trees at runtime (e.g., set per-tree color). ClearExtractionCache public static void ClearExtractionCache(Terrain terrain) public static void ClearAllExtractionCaches() Clear cached tree and detail extraction data for a specific terrain or all terrains. The component caches extraction data to avoid redundant work across enable/disable cycles. Call these when terrain data has changed externally and you need a clean re-extraction. How Trees Work Tree instances are read from the terrain data when the component initializes. They are: Spatially batched into chunks for hierarchical culling Uploaded to the GPU as permanent instances Matched to the prefab assigned in the terrain's tree prototype settings In the editor, tree changes made with Unity's terrain paint tools are detected automatically. The registerer performs an incremental update without needing a manual refresh. How Details Work Terrain details (grass, flowers, small vegetation) are streamed based on camera proximity: The terrain is divided into a grid based on Detail Chunk Size Patches near the camera are loaded using Burst-compiled extraction jobs Patches are unloaded as the camera moves away Extraction runs on worker threads to avoid frame hitches This allows millions of detail instances without loading the entire terrain upfront. See Terrain Detail Spawning for more on the custom extraction algorithm. Editor Behavior Tree and detail changes from Unity's terrain paint tools are detected and updated automatically The component works outside of play mode for editor preview Individual terrain trees can be selected and edited directly in the Scene View using the terrain tree selector tool Notes One BRG Terrain Registerer per Terrain GameObject. The component caches extraction data per terrain. Cached data survives enable/disable cycles to avoid redundant extraction. Per-prefab settings (shadows, density, crossfade) are controlled via BRG Prototype Extra Data on the tree/detail prefabs. Use Clear Caches if you modify terrain data through scripts, as the automatic detection only covers the paint tools."
  },
  "articles/components/index.html": {
    "href": "articles/components/index.html",
    "title": "Components | BRG Instanced Renderer",
    "summary": "Components Full reference for every component in BRG Instanced Renderer. BRG Instanced Renderer Config The global configuration asset. Controls culling, memory, shadows, LOD crossfade, and debug options. BRG Terrain Registerer Registers a Unity Terrain's trees and details for GPU-instanced rendering. BRG Instance Group Converts prefab hierarchies into GPU-instanced rendering with spatial chunking and serialization. BRG Prototype Extra Data Optional per-prefab overrides for shadows, LOD, motion vectors, and dynamic density. BRG Camera Settings Optional per-camera LOD bias multiplier."
  },
  "articles/editor-tools/debugging.html": {
    "href": "articles/editor-tools/debugging.html",
    "title": "Debugging | BRG Instanced Renderer",
    "summary": "Debugging BRG Instanced Renderer provides several debug tools to help diagnose rendering, culling, and performance issues. Debug Flags All debug flags are on the BRG Instanced Renderer Config asset. Enable Debug Logging Outputs verbose console messages for all major operations: prototype registration, chunk allocation, pool resizing, culling dispatches, and more. Useful for understanding what the system is doing step by step. Debug Bypass Chunk Culling Skips the chunk-level culling pass and processes all instances directly. Use this to verify whether a rendering issue is caused by incorrect chunk bounds or overly aggressive chunk culling. Debug Disable Culling Skips the GPU culling pass entirely and reuses the previous frame's visibility results. This isolates the cost of culling in the profiler — if performance improves significantly with culling disabled, the culling pass may need optimization (fewer chunks, larger pool sizes). Debug Disable Rendering Runs the GPU culling pipeline as normal but skips the actual draw command submission. Use this to isolate rendering cost from culling cost in the profiler. Debug Disable Crossfade Forces all LOD transitions to be instant, bypassing animated crossfade. Useful for verifying whether a visual artifact is related to the crossfade system. Debug Visualize Culling In Scene View Freezes the culling frustum to the Game camera's view. You can then orbit freely in the Scene View to see exactly which instances are being culled and which are visible. Instances outside the Game camera's frustum will not be rendered, making it easy to verify frustum culling behavior. Profiler Markers In Development builds, the following profiler markers are available in Unity's Profiler window: Marker Description BRGIR.CameraCulling Time spent dispatching GPU culling for the main camera BRGIR.ShadowCulling Time spent dispatching GPU culling for shadow cascades BRGIR.PostLateUpdate Per-frame maintenance: flushing staged uploads, settling motion vectors BRGIR.WriteChunk Time spent writing instance data to a chunk BRGIR.FreeChunk Time spent releasing a chunk and its pools BRGIR.ResizePoolBuffer Time spent growing the pool buffer (indicates runtime growth) BRGIR.AllocateChunk Time spent allocating a new chunk slot Common Issues Instances not appearing Verify the Config asset is in Preloaded Assets (Edit > Project Settings > Player) Check that only one Config exists in Preloaded Assets Ensure the prefab has a valid Mesh Renderer and Mesh Filter (or LOD Group) If using BRG Instance Group, confirm it shows as converted in the inspector Try enabling Debug Bypass Chunk Culling to rule out culling issues Instances flickering or popping Check if LOD crossfade is set to No Crossfade — switching to Crossfade or Animated Crossfade smooths transitions If using dynamic density, verify the Density Fade Width is not too small Ensure LOD Bias is reasonable (very low values cause aggressive LOD switching) High GPU memory usage Check Pool Size in the Config — smaller values (64) waste less memory on partially-filled pools Lower Max Pools Per Chunk to reduce per-chunk allocation Review the memory estimate in the System Window If Support Legacy Light Probes is enabled, consider whether it's needed — it adds ~65% per-instance buffer cost (128 bytes/instance) Shadow artifacts Verify Max Shadow Cascade is appropriate per-prototype Check that Min Shadow LOD isn't set too high (causing low-poly shadow silhouettes) If shadow cascade seams are visible, increase Max Shadow Crossfade Cascade on the Config or per-prototype Performance issues Open the System Window to check draw command counts and utilization Use Debug Disable Culling and Debug Disable Rendering to isolate CPU vs GPU cost Check for BRGIR.ResizePoolBuffer profiler markers — frequent resizes indicate initial allocations are too small Consider enabling Gathered Allocations to auto-size initial buffers from peak values"
  },
  "articles/editor-tools/index.html": {
    "href": "articles/editor-tools/index.html",
    "title": "Editor Tools | BRG Instanced Renderer",
    "summary": "Editor Tools Tools for monitoring system state and diagnosing issues. System Window Real-time monitoring of rendering state, resource usage, and performance statistics. Debugging Debug flags, profiler markers, and troubleshooting for rendering and culling issues. Terrain Tree Selector Click on terrain trees in the Scene View to select and edit them directly. The tool creates a temporary proxy GameObject for the selected tree, allowing you to move, rotate, and scale it using Unity's standard transform handles. Press Delete to remove the selected tree. Changes are automatically applied back to the terrain data."
  },
  "articles/editor-tools/system-window.html": {
    "href": "articles/editor-tools/system-window.html",
    "title": "System Window | BRG Instanced Renderer",
    "summary": "System Window The BRG Instanced Renderer System Window provides real-time monitoring of the rendering system's state, resource usage, and performance statistics. Open it via Tools > BRG Instanced Renderer > System Window. System Status Shows whether the BRG Instanced Renderer singleton is active or not yet created. Button Description Create Instance Creates the singleton (shown when not active). Full Refresh Clears all caches and re-initializes all registerers (editor only). Runtime Refresh Fast re-initialization of all registerers without clearing caches. Configuration Displays the current Config asset with a Select Asset button to highlight it in the Project window. The full config inspector is shown inline for quick access. Runtime Statistics When the system is initialized (in play mode or editor preview), the window shows live statistics across several collapsible sections. Prototypes Expandable foldout listing all registered prototypes. The header shows active, idle, and vacant prototype counts. Each prototype entry shows: Reference count and instance count (with high-water mark) LOD count and crossfade mode Camera and shadow bucket capacities Shadow settings (max cascade, min shadow LOD, max shadow distance) Button Description Purge Unused Removes idle prototypes with zero references. Shown when idle prototypes exist. Draw Commands Batches — Total active BRG batches Camera / Shadow — Draw command counts for camera and shadow passes Camera Buckets / Shadow Buckets — Bucket slot counts Compute Rendered Triangles Toggle that enables per-frame triangle counting. When enabled, shows: Camera Triangles — Triangles rendered for the main camera pass Shadow Triangles — Triangles rendered for shadow passes Total Triangles — Combined total Chunk System Instances — Total registered instances Chunks — Used / total (free count, high-water mark) Pools — Used / total (free count, pool size) Pool Utilization — Color-coded percentage (red <50%, yellow <70%, green 85%+) with used vs. wasted slot breakdown Occlusion Shown when BRG occlusion culling is active: Visible — Chunks that passed the occlusion test Occluded — Chunks hidden behind occluders Per-View Buffers Camera Sets — Active camera view buffer sets Shadow Sets — Active shadow view buffer sets Fade Views — Active animated crossfade view states Crossfade Shows the animated crossfade system status: Whether animated crossfade is ON or OFF Number of prototypes using it, active views, fade states, and duration Whether Skip Intermediate LODs is enabled Debug Warnings When any debug flags are active on the Config, warning banners appear: \"DEBUG: Chunk culling BYPASSED\" \"DEBUG: Culling DISABLED (reusing stale results)\" \"DEBUG: Rendering DISABLED (culling still runs)\" GPU Memory Expandable foldout showing total allocated GPU memory (color-coded: green <64MB, orange <128MB, yellow <256MB, red >256MB). When expanded, shows per-category breakdown: Prototype Data — GPU prototype buffer Instance Data — Per-instance data (color, density hash, etc.) Matrix Data — Object-to-world matrices Chunk Data — Chunk metadata (bounds, cull distance, etc.) Pool Ref Data — Pool reference tracking Camera View Buffers — Per-camera culling output Shadow View Buffers — Per-shadow-view culling output FadeState Buffers — Animated crossfade per-view states Bucket Mapping — Draw call bucket layouts Staging Buffers — Upload staging memory Use Cases Performance tuning — Monitor draw command counts and pool utilization to identify waste Memory budgeting — Check GPU memory estimates when adjusting pool size or max pools per chunk Debugging — Verify that instances are registering correctly and culling is behaving as expected Gathered allocations — Watch peak values to inform initial allocation settings in the Config"
  },
  "articles/features/culling.html": {
    "href": "articles/features/culling.html",
    "title": "Culling | BRG Instanced Renderer",
    "summary": "Culling BRG Instanced Renderer uses a multi-level GPU-driven culling pipeline to ensure only visible instances consume rendering resources. All culling runs entirely on the GPU via compute shaders, keeping CPU overhead near zero regardless of instance count. Five types of culling work together in a hierarchical pipeline: Frustum Culling Instances outside the camera's field of view are excluded. Tested at both the chunk level and per-instance level for maximum efficiency. Occlusion Culling Chunks fully hidden behind occluders are skipped using Unity's baked occlusion data. Enable via Use BRG Occlusion Culling on the Config. Distance Culling Instances beyond a configurable distance are not rendered. Set per-group via BRG Instance Group or per-terrain via BRG Terrain Registerer. Screen-Size Culling Instances too small on screen are culled automatically, with optional fade-out. Configured per-prefab via BRG Prototype Extra Data. Dynamic Density Culling Gradually thins out instances at distance using a deterministic hash — no flickering. See Dynamic Density for details. Shadow rendering has its own dedicated culling pass, with per-cascade frustum testing and per-prototype cascade limits. See Shadow Optimization for details. For culling settings, see BRG Instanced Renderer Config and BRG Prototype Extra Data."
  },
  "articles/features/dynamic-density.html": {
    "href": "articles/features/dynamic-density.html",
    "title": "Dynamic Density | BRG Instanced Renderer",
    "summary": "Dynamic Density Dynamic density is a GPU-side feature that gradually thins out instances based on distance or screen size. Unlike distance culling which removes all instances beyond a threshold, dynamic density reduces the proportion of visible instances over a range — producing a smooth falloff that's far less noticeable. Each instance has a deterministic hash based on its position, so the same instances are always culled at the same distance. No flickering or randomness. Two Modes Screen Size — Density based on how large the instance appears on screen. Consistent regardless of camera FOV. Distance — Density based on world-space distance. Direct control over falloff in meters. Runtime Density Scaling The system also supports a global runtime density scale via BRGInstancedRenderer.Instance.SetDensity(float), allowing you to dynamically adjust instance density at runtime (e.g., for quality settings or performance scaling). Prototypes must have Enable Density Scaling checked to participate. Best For Grass and ground cover — Thousands of instances where distant thinning is invisible Dense forests — Gradually thin trees at the horizon for smoother falloff Small props and debris — Reduce count at distance without a hard cutoff For density settings, see BRG Prototype Extra Data."
  },
  "articles/features/index.html": {
    "href": "articles/features/index.html",
    "title": "Features | BRG Instanced Renderer",
    "summary": "Features BRG Instanced Renderer includes a suite of GPU-driven features designed to maximize rendering performance while maintaining visual quality. Culling Multi-level GPU culling pipeline with frustum, occlusion, distance, screen-size, and density culling. LOD Groups and Mesh LOD Full LOD Group and Mesh LOD support with three crossfade modes and per-camera LOD bias. Shadow Optimization Per-prefab shadow cascade limits, shadow LOD, and max shadow distance. Dynamic Density GPU-side instance thinning based on distance or screen size. Rendering Features Per-instance motion vectors, rendering layers, and color tinting. Light Probes Adaptive Probe Volumes (APV) and legacy Light Probe Group support. Terrain Detail Spawning Custom jobified detail extraction that replaces Unity's main-thread API with zero GC and no hitches. Streaming & Performance Chunk-based architecture with hitchless streaming and zero GC."
  },
  "articles/features/light-probes.html": {
    "href": "articles/features/light-probes.html",
    "title": "Light Probes | BRG Instanced Renderer",
    "summary": "Light Probes BRG Instanced Renderer supports both of Unity's light probe systems, so GPU-instanced objects receive correct baked indirect lighting. Adaptive Probe Volumes (APV) Unity's modern probe system (Unity 6+). Probe data is stored in a volumetric grid and sampled per-instance on the GPU. Automatically covers the entire scene without manual probe placement. This is the recommended mode for new projects. Legacy Light Probes Traditional Light Probe Group support for existing scenes. Per-instance SH coefficients are sampled and uploaded to the GPU. Enable via Support Legacy Light Probes on the Config. Note Legacy light probes add 128 bytes per instance to the GPU buffer (~65% total per-instance memory increase). Only enable if your project uses Light Probe Groups instead of APV. Terrain detail instances (grass, small rocks, etc.) also receive light probe data automatically based on their position. For light probe settings, see BRG Instanced Renderer Config."
  },
  "articles/features/lod-and-crossfade.html": {
    "href": "articles/features/lod-and-crossfade.html",
    "title": "LOD Groups and Mesh LOD | BRG Instanced Renderer",
    "summary": "LOD Groups and Mesh LOD BRG Instanced Renderer supports two LOD workflows — traditional LOD Groups and Mesh LOD (Unity 6.2+). Both use GPU-side LOD selection as part of the culling pass, so LOD switching has zero CPU cost. LOD Groups Full support for Unity's LOD Group component. LOD thresholds are read directly from your prefab's LOD Group and selected per-instance on the GPU based on screen size. Mesh LOD A single mesh with multiple internal LOD ranges — no LOD Group needed. Reduces memory overhead and simplifies prefab setup. Requires Unity 6.2+. Configured via BRG Prototype Extra Data. Three Crossfade Modes No Crossfade — Instant LOD switch, cheapest option. Crossfade (Stateless) — Dithered blending between LODs based on distance. Animated Crossfade — Smooth time-based transitions with per-instance fade state tracking. LOD Bias Respects Unity's global QualitySettings.lodBias automatically. Add a BRG Camera Settings component for per-camera LOD bias multipliers. Min Screen Size Instances below a configurable screen-size threshold are culled entirely, with optional fade-out using any of the three crossfade modes. For LOD settings, see BRG Prototype Extra Data, BRG Camera Settings, and BRG Instanced Renderer Config."
  },
  "articles/features/rendering-features.html": {
    "href": "articles/features/rendering-features.html",
    "title": "Rendering Features | BRG Instanced Renderer",
    "summary": "Rendering Features BRG Instanced Renderer supports several per-instance rendering features that integrate directly with Unity's rendering pipeline. Motion Vectors Per-instance motion vectors for accurate TAA, temporal upscaling (FSR, DLSS, STP), and motion blur. Can be force-disabled per-prefab to save GPU work on small details like grass. Configured via BRG Prototype Extra Data. Rendering Layers Per-prototype rendering layer masks for selective lighting, decal filtering, and custom pass filtering. Automatically read from each prefab's MeshRenderer settings and respected during all rendering passes including shadows. Per-Instance Color Optional per-instance color tinting. When enabled on the Config, each instance can have a unique color applied as a tint. Useful for vegetation color variation, team coloring, or debug visualization. Shader Compatibility Requires zero modification to your existing shaders. Works with: All default URP/HDRP shaders All Shader Graph shaders All Amplify Shader Editor shaders All proper SRP-compatible shaders For rendering settings, see BRG Prototype Extra Data and BRG Instanced Renderer Config."
  },
  "articles/features/shadow-optimization.html": {
    "href": "articles/features/shadow-optimization.html",
    "title": "Shadow Optimization | BRG Instanced Renderer",
    "summary": "Shadow Optimization Shadow rendering is often the most expensive part of a scene with many instances. BRG Instanced Renderer provides fine-grained per-prefab shadow controls that can dramatically reduce shadow cost without sacrificing visual quality where it matters. Max Shadow Cascade Limit how many shadow cascades a prototype renders into (1–4). Small objects like grass only need cascade 1, cutting shadow cost significantly. Minimum Shadow LOD Force shadows to use a lower-detail mesh. Shadows for LOD0 instances can render using LOD1 or LOD2 geometry, reducing shadow polygon count with no visible impact on silhouettes. Max Shadow Distance Per-prototype distance limit for shadow rendering. Instances beyond this distance cast no shadows, even within an active cascade. Shadow Cascade Crossfade Dithered crossfading between shadow cascades smooths the visible seam where cascades meet. Controllable globally and per-prototype. Per-LOD Shadow Casting Each LOD level respects its MeshRenderer's shadow casting setting. Disable shadow casting on distant LODs to save GPU work automatically. Object Type Recommended Cascade Shadow LOD Shadow Distance Motion Vectors Large trees 4 0 — On Medium vegetation 2–3 1 80–120m On Grass / ground cover 1 0 30–50m Off Small props 2 0 60–80m On For shadow settings, see BRG Prototype Extra Data and BRG Instanced Renderer Config."
  },
  "articles/features/streaming-and-performance.html": {
    "href": "articles/features/streaming-and-performance.html",
    "title": "Streaming & Performance | BRG Instanced Renderer",
    "summary": "Streaming & Performance BRG Instanced Renderer is built for maximum throughput with zero frame hitches, even when streaming millions of instances at runtime. Chunk Architecture Instances are spatially organized into chunks — fixed-size groups of nearby instances. Chunks are the fundamental unit of the culling pipeline: they're culled as a group before per-instance work runs, and they provide spatial locality for GPU cache coherency. Hitchless Streaming When instances are added or removed at runtime, data is streamed to the GPU without stalling the render thread. Terrain details continuously stream around the camera using C# Jobs and Burst Compiler for parallel processing. Zero Hotpath Garbage The rendering hotpath generates zero managed allocations per frame. All per-frame data uses native containers and GPU buffers, ensuring consistent frame times without GC spikes. GPU-Driven Pipeline All culling, LOD selection, and draw call generation runs on the GPU via compute shaders. CPU cost is near-zero regardless of instance count — the CPU only submits a fixed number of compute dispatches and indirect draw calls per frame. Auto-Compaction GPU buffers can be automatically shrunk when waste exceeds 50%, reclaiming memory after large numbers of instances are removed. Configurable on the Config. Editor Performance The system runs in the editor outside of play mode, providing the same rendering performance during scene editing for rapid iteration. For memory and performance settings, see BRG Instanced Renderer Config."
  },
  "articles/features/terrain-detail-spawning.html": {
    "href": "articles/features/terrain-detail-spawning.html",
    "title": "Terrain Detail Spawning | BRG Instanced Renderer",
    "summary": "Terrain Detail Spawning Unity's built-in terrain detail system relies on ComputeDetailInstanceTransforms, which runs on the main thread, allocates garbage every frame, and causes hitches — especially with dense vegetation or large terrains. BRG Instanced Renderer replaces this entirely with a custom detail extraction algorithm that runs on worker threads via the Unity Job System, produces zero garbage, and causes no hitches. How It Works The system reads the terrain's detail density maps directly and computes instance transforms in parallel using Burst-compiled jobs. As the camera moves, new terrain patches are loaded and old ones recycled — all without blocking the main thread or allocating managed memory. Compatibility The custom algorithm reproduces the same placement concepts as Unity's built-in system — density maps, per-layer settings, and terrain patch boundaries are all respected. Instance transforms do not match Unity's output exactly on a per-instance basis, but the overall look and coverage is equivalent. For terrain setup, see Getting Started: Terrain and BRG Terrain Registerer."
  },
  "articles/getting-started/index.html": {
    "href": "articles/getting-started/index.html",
    "title": "Getting Started | BRG Instanced Renderer",
    "summary": "Getting Started Get up and running with BRG Instanced Renderer in minutes. Installation Import the package, verify the configuration asset, and confirm compute shader support. Terrain Register Unity Terrain trees and details for GPU-instanced rendering with the BRG Terrain Registerer component. GameObjects Convert placed prefab hierarchies into GPU-instanced rendering with the BRG Instance Group component."
  },
  "articles/getting-started/installation.html": {
    "href": "articles/getting-started/installation.html",
    "title": "Installation | BRG Instanced Renderer",
    "summary": "Installation Import from Asset Store Open Window > Package Manager. Find BRG Instanced Renderer under My Assets. Click Import. No additional project settings or shader modifications are required. BRG Instanced Renderer works right out of the box with all SRP shaders. Verify the Config Asset After import, a config asset is created automatically at Assets/BRG Instanced Renderer/BRGIRConfig.asset. This asset must be registered in your project's Preloaded Assets to work at runtime. To verify: Open Edit > Project Settings > Player. Scroll to Preloaded Assets. Confirm that BRGIRConfig is listed. If it is not, drag it in from Assets/BRG Instanced Renderer/. Important Only one BRG Instanced Renderer Config asset should exist in Preloaded Assets. Having multiple will cause errors. Compute Shaders The system uses two compute shaders (BRG_Culling and BRG_Upload) for GPU culling and data transfer. These are auto-discovered by name and assigned to the config asset — no manual setup is needed. Next Steps You're ready to start rendering instances. Choose the workflow that fits your use case: Terrain — Register terrain trees and details for GPU-instanced rendering GameObjects — Convert a group of placed prefabs into GPU-instanced rendering"
  },
  "articles/getting-started/prefab-instances.html": {
    "href": "articles/getting-started/prefab-instances.html",
    "title": "GameObjects | BRG Instanced Renderer",
    "summary": "GameObjects The BRG Instance Group component is the primary way to render placed prefab instances through BRG Instanced Renderer. It converts a hierarchy of prefab instances into serialized GPU-ready chunks, with zero runtime transform scanning. Setup 1. Organize Your Instances Create an empty GameObject in your scene to act as the parent. Place your prefab instances as direct children of this object. All children should be instances of prefabs that have a Mesh Renderer (and optionally a LOD Group). You can mix different prefab types under the same parent. 2. Add the Component Add the BRG Instance Group component to the parent GameObject. 3. Configure Settings Setting Description Chunk Size The spatial grid cell size in meters (default: 50m). Instances are grouped into chunks based on their position. Smaller values create more chunks with fewer instances each, which improves culling precision but adds chunk-level overhead. Cull Distance Maximum render distance in meters. Instances beyond this distance are not rendered. Set to 0 for no distance limit. 4. Convert Click Convert Children to Instances in the inspector. This: Groups instances into spatial chunks based on position and chunk size Serializes instance data (position, rotation, scale, prototype) into the component Disables the Mesh Renderers and LOD Groups on the source GameObjects Adds a BRG Instance Link component to each source object for tracking After conversion, the instances are rendered entirely through BRG Instanced Renderer. The source GameObjects remain in the hierarchy for reference and editing. Editing After Conversion If you move, add, or remove source objects after converting, click Refresh in the inspector to rebuild the chunk data. To revert back to standard Unity rendering, click Revert to GameObjects. This re-enables the original Mesh Renderers and LOD Groups. Per-Prefab Settings For fine-grained control over individual prefab types (shadow optimization, LOD crossfade, dynamic density), add a BRG Prototype Extra Data component to the prefab asset itself. These settings are picked up automatically during conversion. Scene View Gizmos When Show Chunk Gizmos is enabled, wireframe boxes are drawn in the Scene View showing each chunk's bounds. The color indicates fill percentage, and labels show the instance count per chunk. Tips Chunk size should roughly match the density of your instances. Dense forests might use 25–50m chunks, while sparse prop placement might use 100m+. Cull distance works well in combination with dynamic density for gradual falloff before the hard cutoff. BRG Instance Group serializes chunk data into the scene, so startup is instant with no runtime scanning cost."
  },
  "articles/getting-started/terrain.html": {
    "href": "articles/getting-started/terrain.html",
    "title": "Terrain | BRG Instanced Renderer",
    "summary": "Terrain The BRG Terrain Registerer component enables GPU-instanced rendering for Unity Terrain trees and details. Trees are extracted once at startup, while details stream dynamically around the camera using C# Jobs and Burst Compiler. Setup 1. Add the Component Add the BRG Terrain Registerer component to any GameObject that has a Terrain component. One registerer per terrain. 2. Configure Settings Setting Description Disable Built-In Rendering Disables the terrain's native tree and detail rendering so BRG takes over (default: enabled) Detail Chunk Size World-space size of detail streaming cells in meters (default: 32m). Snapped to terrain patch boundaries. 3. Enter Play Mode Trees are extracted and uploaded automatically when the component initializes. Details begin streaming around the active camera. That's it — no conversion step needed. The component handles everything on its own. How Trees Work Tree instances are read from the terrain data once at startup. They are spatially batched into chunks and uploaded as permanent instances. Trees use the prefab assigned in Unity's terrain tree prototype settings. If you paint or remove trees in the editor, the registerer detects the change and performs an incremental update automatically. How Details Work Terrain details (grass, flowers, small vegetation) are streamed in and out of GPU memory based on camera proximity. The system: Divides the terrain into a grid of patches based on Detail Chunk Size Loads patches near the camera using Burst-compiled extraction jobs Unloads patches as the camera moves away This streaming approach allows millions of detail instances without loading everything upfront. Per-Prefab Settings Just like prefab instances, terrain tree and detail prototypes support per-prefab customization via BRG Prototype Extra Data. Add the component to the prefab referenced by your terrain prototype to control shadow cascades, dynamic density, crossfade, and more. Tips Detail chunk size should match the scale of your terrain. Smaller values stream more precisely but create more chunks. 32m is a good default for most terrains. For grass and small details, consider setting Max Shadow Cascade to 1 and disabling motion vectors via BRG Prototype Extra Data for significant performance gains. Tree changes made with the terrain paint tool in the editor are detected automatically. Detail changes are also detected and updated incrementally."
  },
  "articles/overview.html": {
    "href": "articles/overview.html",
    "title": "Overview | BRG Instanced Renderer",
    "summary": "Overview What is BRG Instanced Renderer? BRG Instanced Renderer is the fastest GPU instancing solution for Unity. Render massive amounts of instances with minimal draw calls, and stream millions of instances with zero hitching. BRG Instanced Renderer also runs in the editor outside of play mode, for rapid iteration times. The renderer works with zero modifications to your shaders, using the Batch Renderer Group variants that Unity automatically creates for all SRP shaders. Key Features Ultimate Performance Built on Unity's Batch Renderer Group API, everything runs on the GPU via compute shaders. Innovative instance pooling and chunk system for hierarchical culling Hitchless streaming of instances Zero hotpath garbage Multi-Level Culling Five types of GPU-accelerated culling work together to minimize draw calls: Hierarchical frustum culling (chunk-level, then per-instance) Hierarchical occlusion culling via Unity's baked occlusion data Per-instance distance culling Screen-size culling with configurable fade modes Dynamic density culling to thin out distant instances Shadow Optimization Fine-grained per-prefab shadow control: Clamp the maximum shadow cascade per-prefab Set a minimum shadow LOD to render shadows with fewer polygons Limit maximum shadow distance per-prefab Control which shadow cascades use crossfade dithering LOD Groups and Mesh LOD Full LOD group support with multiple crossfade options: No Crossfade, Stateless Crossfade, and Animated Crossfade modes Mesh LOD support — single mesh with internal LOD ranges (Unity 6.2+) Minimum screen-size culling with fade LOD Bias from Quality Settings, with optional per-camera multiplier Option to skip intermediate LODs for faster transitions Rendering Features Per-prototype rendering layers Per-prototype motion vectors toggle for correct TAA and upscaling Per-instance color tinting Both APV and legacy light probe support Runtime density scaling API Terrain Detail System Custom-built terrain detail system using C# Jobs and Burst Compiler. Spawn and stream millions of grass and detail instances around the camera with zero frame hitches. Trees are extracted and uploaded once at startup. Shader Compatibility Requires zero modification to your existing shaders: All default URP/HDRP shaders All Shader Graph shaders All Amplify Shader Editor shaders All proper SRP-compatible shaders Requirements Unity Version: Unity 6+ Render Pipeline: URP or HDRP Graphics API: Any compute-capable graphics API (DX11, DX12, Vulkan, Metal) Tested GPUs GPU Vendor Tested APIs NVIDIA RTX/GTX DX11, DX12, Vulkan AMD DX11, DX12, Vulkan Intel ARC DX11, DX12, Vulkan"
  },
  "articles/support.html": {
    "href": "articles/support.html",
    "title": "Support | BRG Instanced Renderer",
    "summary": "Support Need help with BRG Instanced Renderer? Join the Discord server for questions, bug reports, and community discussion. Join the Discord Server"
  },
  "index.html": {
    "href": "index.html",
    "title": "BRG Instanced Renderer | BRG Instanced Renderer",
    "summary": "BRG Instanced Renderer The fastest GPU Instancing solution on the market. Utilizing Unity's cutting-edge Batch Renderer Group (BRG) technology, this is a true next-gen solution for your project. Get Started Learn More Unity 6+ URP HDRP DX11 / DX12 Vulkan Metal Features Everything you need to render millions of instances at blazing speed. ⚡ Blazing Performance Render millions of instances with minimal CPU overhead using Unity's Batch Renderer Group API and SRP Batcher. \uD83D\uDC41 5-Type Culling System Frustum, occlusion, distance, screen-size, and density culling — all running on the GPU for maximum throughput. \uD83C\uDF04 Shadow Optimization Per-prefab shadow cascade limits, shadow LOD overrides, and max shadow distance for fine-grained shadow control. \uD83D\uDCC8 LOD Groups & Mesh LOD Full LOD Group and Mesh LOD support with crossfade dithering, animated transitions, and per-camera LOD bias. \uD83C\uDF31 Terrain Detail System Custom C# Jobs + Burst powered terrain detail rendering. Stream millions of grass and detail instances with zero hitches. \uD83C\uDFA8 Shader Compatible Works with all SRP shaders out of the box — no custom shaders or material modifications required. Documentation Jump to the section you need. Overview Feature summary, supported platforms, and system requirements. Read more → Features Culling, LOD, shadows, density, terrain details, and more — at a glance. Read more → Getting Started Installation, terrain integration, and GameObject setup. Read more → Components Full reference for every component and inspector property. Read more →"
  }
}